ft_memset:     [OK] [OK] [OK] [NO CRASH] [OK] [OK] [OK] 
[no crash]: your memset does not segfault when null parameter is sent !
Test code:
	ft_memset(((void *)0), 'a', 12);


ft_bzero:      [OK] [OK] [NO CRASH] [OK] 
[no crash]: your bzero does not segfault when null params is sent
Test code:
	ft_bzero(((void *)0), 0x12);


ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] [OK] [OK] [OK] 
[no crash]: your memcpy does not segv with NULL on first params
Test code:
	ft_memcpy(((void *)0), "segfaulter tu dois", 17);


ft_memccpy:    [MISSING]
ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] [OK] [OK] [OK] [OK] 
[crash]: your memmove crash because it read too many bytes or attempt to read on dst !
Test code:
	int size = 10;
	char *dst = electric_alloc(size);
	char *data = electric_alloc(size);

	__builtin___memset_chk (data, 'A', size, __builtin_object_size (data, 0));
	ft_memmove(dst, data, size);
	dst = electric_alloc_rev(size);
	data = electric_alloc_rev(size);
	__builtin___memset_chk (data, 'A', size, __builtin_object_size (data, 0));
	ft_memmove(dst, data, size);
	exit(TEST_SUCCESS);


ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] 
[crash]: your strrchr crash because it read too many bytes or attempt to write on s !
Test code:
	char *src = electric_alloc(10);

	__builtin___strcpy_chk (src, "123456789", __builtin_object_size (src, 2 > 1 ? 1 : 0));
	ft_strrchr(src, 'a');
	src = electric_alloc_rev(10);
	__builtin___strcpy_chk (src, "123456789", __builtin_object_size (src, 2 > 1 ? 1 : 0));
	ft_strrchr(src, 'a');
	exit(TEST_SUCCESS);


ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcat:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strnstr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [KO] [KO] [OK] [OK] [OK] [OK] 
[KO]: your atoi does not work with over long max value
Test code:
	char n[40] = "99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |-1|
     ft_atoi: |-469762049|

[KO]: your atoi does not work with over long min value
Test code:
	char n[40] = "-99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |0|
     ft_atoi: |469762049|

ft_calloc:     [TIMEOUT] [OK] [OK] [OK] [OK] Test code:
	free(ft_calloc(42));


ft_strdup:     [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] 
[no crash]: your strdup does not segv with NULL parameter
Test code:
	ft_strdup(((void *)0));


ft_substr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] {protected}[OK] 
ft_strjoin:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_strtrim:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] {not protected}
ft_split:      [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] {not protected}
[crash]: you did not protect your split
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_split(s, ' ');
	if (!result)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_itoa:       [OK] [OK] [OK] [OK] [OK] [FAILED] [KO] [KO] [OK] 
[fail]: you did not protect your malloc
Test code:

	char *i1 = ft_itoa(-1234);
	if (!i1)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
        itoa: |(null)|
     ft_itoa: |-1234|

[KO]: your itoa does not allocate the good size so the \0 test may be false
Test code:
	int size;
	char *i1;

	i1 = ft_itoa(-5859);
	size = get_last_malloc_size();
	if (size == 6)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        itoa: |6|
     ft_itoa: |27|

[KO]: your itoa does not allocate the good size so the \0 test may be false
Test code:
	int size;
	char *i1;

	i1 = ft_itoa(0);
	size = get_last_malloc_size();
	if (size == 2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        itoa: |2|
     ft_itoa: |27|

ft_strmapi:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_putchar_fd: [OK] [OK] 
ft_putstr_fd:  [OK] [OK] {not protected}
ft_putendl_fd: [OK] [OK] {not protected}
ft_putnbr_fd:  [OK] [OK] [OK] [OK] [OK] 
ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
ft_striteri:   [OK] [OK] {not protected}
